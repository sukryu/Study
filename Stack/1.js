/**
 * 괄호 문자열이 유효한지 확인하기 (예: "(())", "(()))").
 */

function isValidParentheses(s) {
    const stack = [];
    
    for (let i = 0; i < s.length; i++) {
        const char = s[i];
        
        // 열린 괄호를 만나면 스택에 넣습니다.
        if (char === '(') {
            stack.push(char);
        } else if (char === ')') {
            // 닫힌 괄호를 만나면, 스택의 top을 확인합니다.
            if (stack.length === 0) {
                // 스택이 비어있다면, 매칭되는 열린 괄호가 없으므로 유효하지 않습니다.
                return false;
            } else {
                // 매칭되는 열린 괄호가 있다면 pop합니다.
                stack.pop();
            }
        }
    }
    
    // 모든 검사를 마친 후, 스택이 비어있어야 유효한 괄호 문자열입니다.
    return stack.length === 0;
}

// 사용 예시:
console.log(isValidParentheses("(())")); // 출력: true
console.log(isValidParentheses("(()))")); // 출력: false


/**
 * 1. 스택 초기화: 빈 스택을 생성한다.
 * 2. 문자열 순회: 주어진 문자열의 각 문자를 순회하면서:
 *  열린 괄호: ('(':시작 괄호)를 만나면 스택에 넣는다.
 *  닫힌 괄호: (')':종료 괄호)를 만나면 스택의 최상단 요소를 확인한다.
 *      스택이 비어 있다면, 즉시 유효하지 않음을 반환한다. 스택이 비어있지 않다면 최상단 요소를 제거한다.
 * 3. 유효성 검사: 순회를 마친 후 스택이 비어있어야 문자열이 유효하다. 스택에 남아있는 열린
 * 괄호가 있다면, 이는 닫히지 않은 괄호가 있음을 의미하므로 유효하지 않는다.
 * 
 * 이 알고리즘은 각 문자에 대해 한 번씩만 순회하기 때문에 시간 복잡도는 O(n)이다, 여기서
 * n은 입력 문자열의 길이이다. 이 방법은 간단하면서도 매우 효율적이기 때문에 다양한 유형의 괄호 
 * 문제를 해결하는 데 자주 사용된다.
 */